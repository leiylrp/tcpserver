1 TcpServer
    `tcp服务，服务器需要绑定ip地址和端口号，并在该端口号上侦听客户端的连接，
    由成员变量listener负责管理侦听细节。除此之外每当有链接过来时，
    TcpServer需要接收新连接，多个连接存在时，就需要有条不紊的管理这些链接，也就是连接的建立，断开等，
    这就是产生和管理TcpConnection对象`

2 TcpConnection
    `TcpConnection对象又包括两部分，connection对象负责对消息的读写，connectionmanager负责
    管理连接的一些信息，增删改查。这部分除了GetConn之外都是要加锁的。 一个链接对应一个connection对象，
    一个connmanager管理着多个connection对象`

3 TcpSession
    `将收到的数据包进行捷豹，或者对准备好的数据进行装包。并交给channel或者执行对应的router处理`


// 如何解决粘包和拆包？
4 粘包和拆包：TCP它是一种流式协议，对消息无边界，这是TCP协议的规定。 所以当我们的底层是tcp协议时：
        （1）面向流式协议不会按照应用层交付的数据保持边界， 进而出现接受侧可能出现多个包合在一起的数据包，需要应用层去分开。
        （2）用户数据被tcp发出去之后存在多个小数据包被封装在一个tcp报文中的可能，这也是由于tcp内部的一个nagle算法导致。只允许连接上最多只能由一个未被确认的分组。经受时延的确认。较慢的广域网。
            nagle算法：达到MSS立刻发数据包，200ms也会发出去。
    解决办法：
        （1）固定的数据包长度。比如每个包我只固定100个字节，不足的用0填充。超过的就下一个数据包，这样读取数据包就可以按照100字节读取。这其实会将完整的数据包无辜的被拆开了。
        （2）在每个包的末尾使用固定的分隔符，这样在接收端收到数据就可以通过分隔符来进行拆包。
        （3）自己定义消息。我是将消息分成消息id+len+data的形式并以小端字节序存入到socket buffer缓冲区。当数据包从发送方经过网络层、数据链路层、物理层最终到达接收方的传输层时，接收方socket缓冲区会拿到数据。
            我通过两次读的方式进行数据的拆包。第一次当接收方接收数据时，读取固定的8字节，通过小端序从socket buffer中获取到msgid、msglen。然后在socket buffer缓冲区数据部分偏移msglen长度一次性收取数据。然后将当前连接和msg封装成request发送到协程池。

// 如何实现高优先级任务先执行？
    
// 多路由模式如何做的？
    在IRouter内部抽象接口层，定义了三个方法PreHandler、Handler和PostHandler，然后在BaseRouter内部实现层空实现这三个方法，
    这样在外部Router struct继承BaseRouter之后就可以任意实现其中一个方法，这个router struct继承了BaseRouter，也实现了IRouter，
    外部就可以实现其中一个或多个方法，内部就可以按照规定好的顺序去执行。

// 服务器框架包括server服务模块，connection连接与管理模块，session会话模块，任务池模块。
    server服务模块主要负责建立与客户端的连接，然后封装连接交给connection连接与管理模块处理。像在连接建立就处理业务和在连接断开处理业务逻辑、router路由模块、session绘画模块也是在server模块管理。
    将conn、connid、conn属于哪个server、session封装交给连给connection连接与管理模块，这个大模块主要包括：对链接的管理（也就是连接的增删改查）以及对消息的读写分离。
    session会话模块主要就是将消息交给任务池处理。
    任务池有两种，一种是：一个gouroutine处理一个channel当中的所有任务，另外一种是主要通过：自旋锁+环形队列+sync.Pool实现的任务池。
server：通过syscall包里的Socket() Bind() Listen() Accept() 配合epoll实现框架与客户端的通信连接，这里涉及到与客户端建立连接的细节。在创建好与客户端的连接之后，将该连接交给连接与连接管理模块进行消息的读写分离。
        由于tcp是流式协议，不对消息进行边界划分，在框架内部就对消息进行了边界处理，减少了客户端和服务端处理消息边界负担。然后将读取的消息和方法处理的方法封装成之后，这里呢我是将所有从socket都交给channel，然后一个goroutine去处理。处理完之后将